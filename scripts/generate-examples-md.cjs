#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const { z } = require('zod');

const ROOT = path.resolve(__dirname, '..');
const EXAMPLES_DIR = path.join(ROOT, 'examples');
const OUTPUT_FILE = path.join(ROOT, 'EXAMPLES.md');

const exampleMetadataSchema = z.object({
  title: z.string().min(1),
  slug: z.string().min(1),
  use_case: z.string().min(1),
  workflow: z.array(z.string().min(1)).min(1),
  tags: z.array(z.string().min(1)).min(1),
  prerequisites: z.array(z.string().min(1)).min(1),
  run: z.string().min(1),
  test: z.string().min(1),
});

function readExampleFiles() {
  return fs
    .readdirSync(EXAMPLES_DIR)
    .filter((file) => file.endsWith('.ts') && file !== 'types.ts')
    .sort();
}

function parseFrontmatterFromFile(contents, filePath) {
  const commentMatch = contents.match(/(?:^#!.*\n)?\s*\/\*\*([\s\S]*?)\*\//);
  if (!commentMatch) {
    throw new Error(`${filePath}: missing top-level docstring block comment`);
  }

  const commentBody = commentMatch[1];
  const frontmatterMatch = commentBody.match(/---\s*\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    throw new Error(`${filePath}: missing frontmatter delimited by ---`);
  }

  try {
    return yaml.load(frontmatterMatch[1], { schema: yaml.JSON_SCHEMA });
  } catch (error) {
    throw new Error(
      `${filePath}: failed to parse frontmatter YAML: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

function validateMetadata(metadata, filePath, seenSlugs) {
  const parsed = exampleMetadataSchema.safeParse(metadata);
  if (!parsed.success) {
    const issues = parsed.error.issues.map((issue) => issue.message).join('; ');
    throw new Error(`${filePath}: invalid metadata schema: ${issues}`);
  }

  if (seenSlugs.has(parsed.data.slug)) {
    throw new Error(`${filePath}: duplicate slug "${parsed.data.slug}"`);
  }
  seenSlugs.add(parsed.data.slug);
  return parsed.data;
}

function markdownForExample(example) {
  return [
    `## ${example.title}`,
    '',
    `**Use case:** ${example.use_case}`,
    '',
    `**Tags:** ${example.tags.map((tag) => `\`${tag}\``).join(', ')}`,
    '',
    '### Workflow',
    ...example.workflow.map((step) => `- ${step}`),
    '',
    '### Prerequisites',
    ...example.prerequisites.map((item) => `- \`${item}\``),
    '',
    '### Run',
    '```sh',
    example.run,
    '```',
    '',
    '### Test',
    '```sh',
    example.test,
    '```',
    '',
    `**Source:** [\`examples/${example.fileName}\`](./examples/${example.fileName})`,
    '',
  ].join('\n');
}

function generateMarkdown(examples) {
  const toc = examples.map((example) => `- [${example.title}](#${example.slug})`).join('\n');

  const sections = examples.map((example) => markdownForExample(example)).join('\n');

  return [
    '# Examples',
    '',
    '> This file is auto-generated from metadata in `examples/*.ts`.',
    '> Do not edit this file manually. Run `yarn generate:examples-md` instead.',
    '',
    'Runnable examples live in [`examples/`](./examples).',
    '',
    '## Table of Contents',
    '',
    toc,
    '',
    sections.trimEnd(),
    '',
  ].join('\n');
}

function main() {
  const files = readExampleFiles();
  const seenSlugs = new Set();

  const examples = files.map((fileName) => {
    const filePath = path.join(EXAMPLES_DIR, fileName);
    const contents = fs.readFileSync(filePath, 'utf8');
    const rawMetadata = parseFrontmatterFromFile(contents, filePath);
    const metadata = validateMetadata(rawMetadata, filePath, seenSlugs);
    return {
      ...metadata,
      fileName,
    };
  });

  examples.sort((a, b) => a.title.localeCompare(b.title));
  const markdown = generateMarkdown(examples);
  fs.writeFileSync(OUTPUT_FILE, markdown);
  process.stdout.write(`Wrote ${path.relative(ROOT, OUTPUT_FILE)} from ${examples.length} example(s)\n`);
}

main();
