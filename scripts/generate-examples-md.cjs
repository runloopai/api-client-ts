#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');
const { z } = require('zod');

const ROOT = path.resolve(__dirname, '..');
const EXAMPLES_DIR = path.join(ROOT, 'examples');
const OUTPUT_FILE = path.join(ROOT, 'EXAMPLES.md');
const OUTPUT_REGISTRY_FILE = path.join(EXAMPLES_DIR, 'registry.ts');
const LLMS_FILE = path.join(ROOT, 'llms.txt');

const exampleMetadataSchema = z.object({
  title: z.string().min(1),
  slug: z.string().min(1),
  use_case: z.string().min(1),
  workflow: z.array(z.string().min(1)).min(1),
  tags: z.array(z.string().min(1)).min(1),
  prerequisites: z.array(z.string().min(1)).min(1),
  run: z.string().min(1),
  test: z.string().min(1),
});

function readExampleFiles() {
  return fs
    .readdirSync(EXAMPLES_DIR)
    .filter(
      (file) =>
        file.endsWith('.ts') &&
        !file.startsWith('_') &&
        file !== 'types.ts' &&
        file !== 'registry.ts',
    )
    .sort();
}

function parseFrontmatterFromFile(contents, filePath) {
  const commentMatch = contents.match(/(?:^#!.*\n)?\s*\/\*\*([\s\S]*?)\*\//);
  if (!commentMatch) {
    throw new Error(`${filePath}: missing top-level docstring block comment`);
  }

  const commentBody = commentMatch[1];
  const frontmatterMatch = commentBody.match(/---\s*\n([\s\S]*?)\n---/);
  if (!frontmatterMatch) {
    throw new Error(`${filePath}: missing frontmatter delimited by ---`);
  }

  try {
    return yaml.load(frontmatterMatch[1], { schema: yaml.JSON_SCHEMA });
  } catch (error) {
    throw new Error(
      `${filePath}: failed to parse frontmatter YAML: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

function validateMetadata(metadata, filePath, seenSlugs) {
  const parsed = exampleMetadataSchema.safeParse(metadata);
  if (!parsed.success) {
    const issues = parsed.error.issues.map((issue) => issue.message).join('; ');
    throw new Error(`${filePath}: invalid metadata schema: ${issues}`);
  }

  if (seenSlugs.has(parsed.data.slug)) {
    throw new Error(`${filePath}: duplicate slug "${parsed.data.slug}"`);
  }
  seenSlugs.add(parsed.data.slug);
  return parsed.data;
}

function normalizeFileSlug(fileName) {
  return fileName.replace(/\.ts$/, '');
}

function validateRunCommand(example, filePath) {
  const expectedSnippet = `examples/${example.fileName}`;
  if (!example.run.includes(expectedSnippet)) {
    throw new Error(`${filePath}: run command must reference "${expectedSnippet}"`);
  }
}

function validateSlugMatchesFileName(example, filePath) {
  const fileSlug = normalizeFileSlug(example.fileName);
  if (example.slug !== fileSlug) {
    throw new Error(`${filePath}: slug "${example.slug}" must match file name "${fileSlug}"`);
  }
}

function normalizeEnvVar(prerequisite) {
  const match = prerequisite.match(/^[A-Z0-9_]+/);
  return match ? match[0] : null;
}

function ensureLlmsReferences(examples) {
  if (!fs.existsSync(LLMS_FILE)) {
    throw new Error(`Missing llms file: ${path.relative(ROOT, LLMS_FILE)}`);
  }

  const llmsText = fs.readFileSync(LLMS_FILE, 'utf8');
  const referencedFiles = new Set();

  const matches = llmsText.matchAll(/examples\/([a-z0-9-]+\.ts)/g);
  for (const match of matches) {
    referencedFiles.add(match[1]);
  }

  if (referencedFiles.size === 0) {
    throw new Error(
      `${path.relative(ROOT, LLMS_FILE)}: expected at least one reference to examples/*.ts`,
    );
  }

  const generatedFiles = new Set(examples.map((example) => example.fileName));
  for (const fileName of referencedFiles) {
    if (!generatedFiles.has(fileName)) {
      throw new Error(
        `${path.relative(ROOT, LLMS_FILE)}: references unknown example file "examples/${fileName}"`,
      );
    }
  }
}

function markdownForExample(example) {
  return [
    `## ${example.title}`,
    '',
    `**Use case:** ${example.use_case}`,
    '',
    `**Tags:** ${example.tags.map((tag) => `\`${tag}\``).join(', ')}`,
    '',
    '### Workflow',
    ...example.workflow.map((step) => `- ${step}`),
    '',
    '### Prerequisites',
    ...example.prerequisites.map((item) => `- \`${item}\``),
    '',
    '### Run',
    '```sh',
    example.run,
    '```',
    '',
    '### Test',
    '```sh',
    example.test,
    '```',
    '',
    `**Source:** [\`examples/${example.fileName}\`](./examples/${example.fileName})`,
    '',
  ].join('\n');
}

function generateMarkdown(examples) {
  const toc = examples.map((example) => `- [${example.title}](#${example.slug})`).join('\n');

  const sections = examples.map((example) => markdownForExample(example)).join('\n');

  return [
    '# Examples',
    '',
    '> This file is auto-generated from metadata in `examples/*.ts`.',
    '> Do not edit this file manually. Run `yarn generate:examples-md` instead.',
    '',
    'Runnable examples live in [`examples/`](./examples).',
    '',
    '## Table of Contents',
    '',
    toc,
    '',
    sections.trimEnd(),
    '',
  ].join('\n');
}

function toRunnerName(fileName) {
  const base = fileName
    .replace(/\.ts$/, '')
    .split('-')
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
  return `run${base}Example`;
}

function generateRegistry(examples) {
  const imports = examples
    .map((example) => {
      const runnerName = toRunnerName(example.fileName);
      const importPath = `./${example.fileName.replace(/\.ts$/, '')}`;
      return `import { ${runnerName} } from '${importPath}';`;
    })
    .join('\n');

  const entries = examples
    .map((example) => {
      const runnerName = toRunnerName(example.fileName);
      const requiredEnv = example.prerequisites
        .map((item) => normalizeEnvVar(item))
        .filter(Boolean)
        .map((envName) => `'${envName}'`)
        .join(', ');
      return `  {
    slug: '${example.slug}',
    title: ${JSON.stringify(example.title)},
    fileName: '${example.fileName}',
    live: true,
    requiredEnv: [${requiredEnv}],
    run: ${runnerName},
  },`;
    })
    .join('\n');

  return `/**
 * This file is auto-generated by scripts/generate-examples-md.cjs.
 * Do not edit manually.
 */
import type { ExampleResult } from './types';
${imports}

export interface ExampleRegistryEntry {
  slug: string;
  title: string;
  fileName: string;
  live: boolean;
  requiredEnv: string[];
  run: (options?: any) => Promise<ExampleResult>;
}

export const exampleRegistry: ExampleRegistryEntry[] = [
${entries}
];
`;
}

function main() {
  const files = readExampleFiles();
  const seenSlugs = new Set();

  const examples = files.map((fileName) => {
    const filePath = path.join(EXAMPLES_DIR, fileName);
    const contents = fs.readFileSync(filePath, 'utf8');
    const rawMetadata = parseFrontmatterFromFile(contents, filePath);
    const metadata = validateMetadata(rawMetadata, filePath, seenSlugs);
    validateSlugMatchesFileName({ ...metadata, fileName }, filePath);
    validateRunCommand({ ...metadata, fileName }, filePath);
    return {
      ...metadata,
      fileName,
    };
  });

  examples.sort((a, b) => a.title.localeCompare(b.title));
  ensureLlmsReferences(examples);
  const markdown = generateMarkdown(examples);
  const registrySource = generateRegistry(examples);
  fs.writeFileSync(OUTPUT_FILE, markdown);
  fs.writeFileSync(OUTPUT_REGISTRY_FILE, registrySource);
  process.stdout.write(`Wrote ${path.relative(ROOT, OUTPUT_FILE)} from ${examples.length} example(s)\n`);
  process.stdout.write(`Wrote ${path.relative(ROOT, OUTPUT_REGISTRY_FILE)} from ${examples.length} example(s)\n`);
}

main();
